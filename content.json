{"meta":{"title":"Moonm3n's blog","subtitle":"","description":"","author":"Yueyang Zhan","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"oceanbase-competition-final","slug":"oceanbase-competition-final","date":"2021-12-25T14:07:57.000Z","updated":"2021-12-25T14:07:57.586Z","comments":true,"path":"2021/12/25/oceanbase-competition-final/","link":"","permalink":"http://example.com/2021/12/25/oceanbase-competition-final/","excerpt":"","text":"","categories":[{"name":"paper","slug":"paper","permalink":"http://example.com/categories/paper/"}],"tags":[]},{"title":"15-445 BUFFER POOL","slug":"CMU-15-445-PROJECT-1-BUFFER-POOL","date":"2021-12-14T13:49:17.000Z","updated":"2021-12-14T14:10:22.955Z","comments":true,"path":"2021/12/14/CMU-15-445-PROJECT-1-BUFFER-POOL/","link":"","permalink":"http://example.com/2021/12/14/CMU-15-445-PROJECT-1-BUFFER-POOL/","excerpt":"","text":"","categories":[{"name":"database course","slug":"database-course","permalink":"http://example.com/categories/database-course/"}],"tags":[{"name":"cmu 15-445","slug":"cmu-15-445","permalink":"http://example.com/tags/cmu-15-445/"}]},{"title":"oceanBase 数据库大赛","slug":"oceanBase-数据库大赛","date":"2021-11-25T06:49:26.000Z","updated":"2022-01-04T05:43:23.471Z","comments":true,"path":"2021/11/25/oceanBase-数据库大赛/","link":"","permalink":"http://example.com/2021/11/25/oceanBase-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"赛题描述在开源版本 OceanBase 的基础上, 针对 Nested Loop Join 场景做性能优化. 采用 sysbench 基准测试中 Throughput 的 events/s (eps) 这一项作为排名依据. 赛题解析什么是 Nested Loop Join?Nested Loop Join 是一种常见的数据库查询操作, 其中两个表的数据量相对较小, 且两个表的关联关系相对较简单.Nested Loop Join 的基本原理是每次从左表获取一行, 然后用这行数据和右表进行 Join. 与右表进行 Join 时, 可以通过索引查询降低复杂度. 表结构123456789101112131415local queryquery = string.format([[ CREATE TABLE t%d( c1 int primary key, c2 int, c3 int, v1 CHAR(60), v2 CHAR(60), v3 CHAR(60), v4 CHAR(60), v5 CHAR(60), v6 CHAR(60), v7 CHAR(60), v8 CHAR(60), v9 CHAR(60) )]], table_id)do_query(drv, con, &quot;create index t2_i1 on t2(c2) local&quot;)do_query(drv, con, &quot;create index t2_i2 on t2(c3) local&quot;)ival = sysbench.rand.default(1, sysbench.opt.table_size)left_min = ival - 100;left_max = ival + 100;cond = string.format(&quot;A.c1 &gt;= %d and A.c1 &lt; %d and A.c2 = B.c2 and A.c3 = B.c3&quot;, left_min, left_max)query = &quot;select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where &quot; .. cond 查询语句123456789101112131415161. 原始查询语句 select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and A.c2 = B.c2 and A.c3 = B.c3; select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and A.c2 = B.c2 and A.c3 = B.c3; explain select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and A.c2 = B.c2 and A.c3 = B.c3;2. 当 A.c1 = A.c2 时, 改写后的查询语句 select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and B.c2 &gt;= 100 and B.c2 &lt; 200 and A.c3 = B.c3; select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and B.c2 &gt;= 100 and B.c2 &lt; 200 and A.c3 = B.c3; explain select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and B.c2 &gt;= 100 and B.c2 &lt; 200 and A.c3 = B.c3;","categories":[{"name":"paper","slug":"paper","permalink":"http://example.com/categories/paper/"}],"tags":[]},{"title":"GFS 论文研读","slug":"GFS-论文研读","date":"2021-11-13T05:27:52.000Z","updated":"2021-11-13T05:27:52.790Z","comments":true,"path":"2021/11/13/GFS-论文研读/","link":"","permalink":"http://example.com/2021/11/13/GFS-%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"paper","slug":"paper","permalink":"http://example.com/categories/paper/"},{"name":"database course","slug":"database-course","permalink":"http://example.com/categories/database-course/"}],"tags":[{"name":"cmu 15-445","slug":"cmu-15-445","permalink":"http://example.com/tags/cmu-15-445/"}]}