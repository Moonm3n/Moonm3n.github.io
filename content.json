{"meta":{"title":"Moonm3n's blog","subtitle":"","description":"","author":"Yueyang Zhan","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"tinykv-project2-RaftKV-PartC","slug":"tinykv-project2-RaftKV-PartC","date":"2022-02-24T01:48:10.000Z","updated":"2022-03-03T07:45:00.880Z","comments":true,"path":"2022/02/24/tinykv-project2-RaftKV-PartC/","link":"","permalink":"http://example.com/2022/02/24/tinykv-project2-RaftKV-PartC/","excerpt":"tinykv project 2 part b, 实现快照机制, 定期对日志进行压缩.","text":"tinykv project 2 part b, 实现快照机制, 定期对日志进行压缩. snapshot 的实现分为两个部分. 实现日志的定期清理. 实现 snapshot 数据的发送. 问题记录1. panic: requested entry at index is unavailable这个错误发生在节点重启, 从 storage 中恢复 entries 时. debug 发现 storage 中仅存储了 lo 所在的那一个 entry, 没有 lo 到 hi 之间的 entries.回归测试 2b 后发现也出现了这个问题, 应该是写 2c 时影响到了. 修改 SaveRaftReady() 中应用 snapshot 和 append entries 的顺序后修复. 2. FAIL: TestSnapshotUnreliableRecoverConcurrentPartition2C没有任何错误提示.看日志发现 leader 在不停地 send append.debug 发现 first index 小于 truncated index 了, 怀疑 truncated index 或者 first index 的持久化有问题.debug 发现 send snapshot 的逻辑有问题, 无法发送 snapshot. 3. FAIL: panic: runtime error: slice bounds out of range [1186:384]更改 raft log 的 first index 时没有修改 entries 数组, 导致 从 entries 数组中取 entry 的逻辑出错. 4. panic: Key not foundleader 请求生成 snapshot 后分区恢复, 出现了新 leader, 新 leader 再次请求 snapshot 时便会触发这个问题.apply snapshot 时使用 snapData 的 Region 后解决. 5. panic: request timeoutleader 一直在请求 snapshot, 随后就 timeout 了.apply snapshot 时使用 snapData 的 Region 后解决.","categories":[{"name":"database project","slug":"database-project","permalink":"http://example.com/categories/database-project/"}],"tags":[{"name":"tinykv","slug":"tinykv","permalink":"http://example.com/tags/tinykv/"}]},{"title":"tinykv-project2-RaftKV-PartB","slug":"tinykv-project2-RaftKV-PartB","date":"2022-02-03T09:56:59.000Z","updated":"2022-02-24T09:20:24.296Z","comments":true,"path":"2022/02/03/tinykv-project2-RaftKV-PartB/","link":"","permalink":"http://example.com/2022/02/03/tinykv-project2-RaftKV-PartB/","excerpt":"tinykv project 2 part b, 利用 Raft 模块构建容错的 KV 存储服务.","text":"tinykv project 2 part b, 利用 Raft 模块构建容错的 KV 存储服务. Store: 一个 tinykv-server Peer: tinykv-server 中运行的一个 raft node Region: Peer 的集合, 即一个 Raft group peer storageraft ready processHandleRaftReady get the ready from Raft module. persisting log entries. applying committed entries. sending Raft message to other peers. 问题记录1. panic: find no region for 30203030303030303030raft.go newRaft()优先使用 storage 中的 confState.Nodes 的值. 2. panic: runtime error: index out of range [18446744073709551611] with length 1raft.go sendAppend()index 处理有问题 3. 空指针snap 的 response 需要携带 Region, cd 的 Txn 需要赋值, 否则会出现空指针异常. 4. can’t call command header on leader nWaitRespWithTimeout 超时了. 不停地向 router.peerSender 中发送消息, 导致管道堵塞, 引发卡死.Ready() 函数里没有清空 msg. 5. panic: [region 1] 2 unexpected raft log index— FAIL: TestPersistPartition2B (27.40s)panic: [region 1] 2 unexpected raft log index: lastIndex 33539 &lt; appliedIndex 33810 [recovered] 看起来像是 lastIndex 持久化的逻辑有问题, 重启节点时监测到 lastIndex 比 appliedIndex 更小, 引发 panic.修改了持久化的逻辑后变成了偶现 bug, 1% 几率出现. 修复问题 6 后消失. 6. panic: runtime error: index out of range [1091] with length 1087偶现 bug, 3% 几率出现.bug 出现时, 这两个 index 的差值绝大多数时候为 5, length 为 1087 时, 最后一个元素应该是 [1086].看了日志, 在 partition 情况下才会发生. leader progress 里存储的 next 比自身的 lastIndex 大了更多.加日志后实锤, append entries 返回了大于 leader.lastIndex 的 index, leader 用这个 index 更新了 next,于是出现了数组越界. 错误原因:becomeFollower 时将 Vote 设置为了 None, partition 后有可能选出两个 7. panic: len(resp.Responses) != 1偶现 bug, 1% 几率出现.panic: len(resp.Responses) != 1 goroutine 439 [running]:github.com/pingcap-incubator/tinykv/kv/test_raftstore.(*Cluster).MustPutCF(0xc00011f5c0, 0x47f01a0, 0x7, 0xc22a37f5d0, 0xa, 0x10, 0xc22a37f5e0, 0x9, 0x10) /Users/moon/GolandProjects/tinykv/kv/test_raftstore/cluster.go:308 +0x24dgithub.com/pingcap-incubator/tinykv/kv/test_raftstore.(*Cluster).MustPut(…) /Users/moon/GolandProjects/tinykv/kv/test_raftstore/cluster.go:298github.com/pingcap-incubator/tinykv/kv/test_raftstore.GenericTest.func1(0x1, 0xc000001e00) /Users/moon/GolandProjects/tinykv/kv/test_raftstore/test_test.go:211 +0x41fgithub.com/pingcap-incubator/tinykv/kv/test_raftstore.runClient(0xc000001e00, 0x1, 0xc21c12fb60, 0xc21e28acf0) /Users/moon/GolandProjects/tinykv/kv/test_raftstore/test_test.go:27 +0x7acreated by github.com/pingcap-incubator/tinykv/kv/test_raftstore.SpawnClientsAndWait /Users/moon/GolandProjects/tinykv/kv/test_raftstore/test_test.go:37 +0xb2FAIL github.com/pingcap-incubator/tinykv/kv/test_raftstore 23.630sFAILrm -rf /tmp/test-raftstore 修复问题 6 后消失.","categories":[{"name":"database project","slug":"database-project","permalink":"http://example.com/categories/database-project/"}],"tags":[{"name":"tinykv","slug":"tinykv","permalink":"http://example.com/tags/tinykv/"}]},{"title":"tinykv-project2-RaftKV-PartA","slug":"tinykv-project2-RaftKV-PartA","date":"2022-01-17T07:30:04.000Z","updated":"2022-02-10T07:57:54.760Z","comments":true,"path":"2022/01/17/tinykv-project2-RaftKV-PartA/","link":"","permalink":"http://example.com/2022/01/17/tinykv-project2-RaftKV-PartA/","excerpt":"tinykv project 2 part a, 实现基本的 Raft 算法.","text":"tinykv project 2 part a, 实现基本的 Raft 算法. 2aa leader electionleader election 流程 什么时候开始选举? follow 在超时时间内没有收到心跳, 认为 leader 已经失效, 转变为 candidate 开始选举. 选举超时时, 没有节点赢得选举, 所有 candidate 会随机等待一段时间, 然后重新选举. candidate 是怎样选举的? 成为 candidate 后首先自增 term. 为自己投票. 重制选举超时计时器. 发送请求投票的 RPC 给其他所有服务器. candidate 怎样结束选举? 接收到大多数节点的选票, 成为 leader 并立即向其他节点发送心跳. 发现了其他 leader, 且这个 leader 的 term 不小于自己的 term. 选举超时, candidate 会随机等待一段时间, 再次自增 term, 然后重新选举. follower 怎样投票? 每个 follower 只会对一个 term 投一次票. 申请选票的 candidate 必须包含所有已提交的日志. leader election 实现Raft 算法的 leader election 是在时钟超时时触发的, tinykv 的 Raft 算法采用逻辑时钟来进行计时, 首先需要确定在哪里处理超时, 开始 leader election.观察一下 Raft 结构体的成员, 逻辑时钟的值应该存放在 heartbeatElapsed 和 electionElapsed 这两个变量中. heartbeatElapsed 记录了上次心跳超时以来的 ticks 数, 只有 leader 会保持这个值, 超时时发送心跳. electionElapsed 对 leader 和 candidate 而言, 记录了上次选举超时以来的 ticks 数; 对 follower 而言, 记录了上次收到 leader 的有效消息以来的 ticks 数. 超时时启动选举. 比较合理的做法是在 tick() 方法中递增逻辑时钟并监测超时. tick() 方法中,如果当前节点是 leader, 则更新 heartbeatElapsed 和 electionElapsed 的值, 并且检查是否超时.如果超时, 则转换为 candidate 节点. 如果当前节点是 candidate, 则检查是否超时, 如果超时, 则重新选举. 如果当前节点是 follower, 则检查是否收到 leader 的有效消息, 如果收到, 则更新 electionElapsed 的值.如果没有收到 leader 的有效消息, 则重新选举. 如果当前节点是 candidate, 则检查是否收到 leader 的有效消息, 如果收到, 则转换为 follower 节点. newRaft() 需要处理的消息类型: MessageType_MsgHup 成为 candidate 并开始选举. MessageType_MsgBeat 只有 leader 会接受这个消息, 向所有 peer 广播心跳. MessageType_MsgRequestVote MessageType_MsgRequestVoteResponse 只有 candidate 会接受这个消息. 2ab log replicationlog replication 相关概念日志的几个 index: stabled: 已经被持久化的日志的最大 index. committed: 已经被提交的日志的最大 index. applied: 已经被应用的日志的最大 index. 日志先被 stabled, 再被 commit, 最后被 applied. snapshot/first…..applied….committed….stabled…..last log replication 流程 节点成为 leader 时将所有 peer 的 nextIndex 初始化为 lastIndex + 1, 所有 peer 的 matchIndex 初始化为 0. 接收到 client 请求, 将请求添加到自己的日志中. 发送 AppendEntries RPC 给所有 peer, 并等待所有 peer 的回复. log replication 实现日志的 index 从 1 开始, committed, applied, stabled 应该日志的 index 而不是切片的下标. 2ac raw node interfaceReady{}Ready 封装了可以读取、持久化、提交的状态. Entries: specifies entries to be saved to stable storage BEFORE messages are sent.CommittedEntries: specifies entries to be committed to a store/state-machine.These have previously been committed to stable store.Ready() Advanced()","categories":[{"name":"database project","slug":"database-project","permalink":"http://example.com/categories/database-project/"}],"tags":[{"name":"tinykv","slug":"tinykv","permalink":"http://example.com/tags/tinykv/"}]},{"title":"Raft-论文研读","slug":"Raft-论文研读","date":"2022-01-17T05:59:05.000Z","updated":"2022-01-17T16:00:51.764Z","comments":true,"path":"2022/01/17/Raft-论文研读/","link":"","permalink":"http://example.com/2022/01/17/Raft-%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/","excerpt":"","text":"","categories":[{"name":"paper","slug":"paper","permalink":"http://example.com/categories/paper/"}],"tags":[{"name":"Raft","slug":"Raft","permalink":"http://example.com/tags/Raft/"}]},{"title":"tinykv-project1-StandaloneKV","slug":"tinykv-project1-StandaloneKV","date":"2022-01-16T11:37:20.000Z","updated":"2022-01-17T07:13:44.400Z","comments":true,"path":"2022/01/16/tinykv-project1-StandaloneKV/","link":"","permalink":"http://example.com/2022/01/16/tinykv-project1-StandaloneKV/","excerpt":"tinykv project 1, 基于 badger 构造一个单机的支持列族存储的 gRPC 服务.","text":"tinykv project 1, 基于 badger 构造一个单机的支持列族存储的 gRPC 服务. 题目目标基于 badger 构造一个单机的支持列族存储的 gRPC 服务.这一服务提供四种基本操作: Put/Delete/Get/Scan. Put: 向指定列族中写入或修改. Get: 从指定列族中读取. Delete: 删除指定列族的指定值. Scan: 从指定列族中读取多个值. 要求实现的接口123456789101112type Storage interface &#123; Start() error Stop() error Write(ctx *kvrpcpb.Context, batch []Modify) error Reader(ctx *kvrpcpb.Context) (StorageReader, error)&#125;type StorageReader interface &#123; GetCF(cf string, key []byte) ([]byte, error) IterCf(cf string) engine_util.DBIterator Close()&#125; Storage 的 Write 方法接收一个 Context 指针 ctx 和一个 Modify 数组batch.Modify 是 interface{} 的一个简单封装, 而 Context 可暂时不管, 在后续项目中才会用到. 官方给的几个提示: Reader() 方法需要使用 badger.Txn, Reader close 时先将所有 iterator close, 再调用 txn.Discard(). Badger 不提供对列族的支持, engine_util package (kv/util/engine_util) 包通过向 key 添加前缀的方式支持列族. storage 有三个实现类: MemStorage, RaftStorage, StandAloneStorage. MemStorage:不需要 Start() 与 Stop(), 一个 llrb.LLRB 便是一个 CF, 只需要调用 llrb.LLRB 的 ReplaceOrInsert(item)、Delete(item)、Get(item) 等方法即可. RaftStorage:Start() 时根据 config 新建一些 client 与 worker 并启动, Stop() 时将它们停止.Write() 先将 batch 进行解析, 再调用 raftRouter.SendRaftCommand(request, cb) 将消息发向 raft 集群. StandAloneStorage:要求实现的部分, 类比 RaftStorage 即可. 其他在 macOS 上切换 go 版本用 1.17.5 版本的 go 运行 project 时会有奇怪的 errorfatal error: unexpected signal during runtime execution.看了一下 issues 应该是 go 版本的锅, 降级到 1.16.x 便可. 在 macOS 中可以使用 brew 方便地管理版本. 1234567# 安装 gobrew install go# 安装 go 1.16brew install go@1.16# 切换到 go 1.16brew unlink gobrew link go@1.16","categories":[{"name":"database project","slug":"database-project","permalink":"http://example.com/categories/database-project/"}],"tags":[{"name":"tinykv","slug":"tinykv","permalink":"http://example.com/tags/tinykv/"}]},{"title":"oceanbase-competition-final","slug":"oceanbase-competition-final","date":"2021-12-25T14:07:57.000Z","updated":"2022-01-06T13:18:59.119Z","comments":true,"path":"2021/12/25/oceanbase-competition-final/","link":"","permalink":"http://example.com/2021/12/25/oceanbase-competition-final/","excerpt":"","text":"doing","categories":[{"name":"paper","slug":"paper","permalink":"http://example.com/categories/paper/"}],"tags":[]},{"title":"15-445 BUFFER POOL","slug":"CMU-15-445-PROJECT-1-BUFFER-POOL","date":"2021-12-14T13:49:17.000Z","updated":"2021-12-14T14:10:22.955Z","comments":true,"path":"2021/12/14/CMU-15-445-PROJECT-1-BUFFER-POOL/","link":"","permalink":"http://example.com/2021/12/14/CMU-15-445-PROJECT-1-BUFFER-POOL/","excerpt":"","text":"","categories":[{"name":"database course","slug":"database-course","permalink":"http://example.com/categories/database-course/"}],"tags":[{"name":"cmu 15-445","slug":"cmu-15-445","permalink":"http://example.com/tags/cmu-15-445/"}]},{"title":"oceanBase 数据库大赛","slug":"oceanBase-数据库大赛","date":"2021-11-25T06:49:26.000Z","updated":"2022-01-06T07:15:16.780Z","comments":true,"path":"2021/11/25/oceanBase-数据库大赛/","link":"","permalink":"http://example.com/2021/11/25/oceanBase-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"赛题描述在开源版本 OceanBase 的基础上, 针对 Nested Loop Join 场景做性能优化. 采用 sysbench 基准测试中 Throughput 的 events/s (eps) 这一项作为排名依据. 赛题解析什么是 Nested Loop Join?Nested Loop Join 是一种常见的数据库查询操作, 其中两个表的数据量相对较小, 且两个表的关联关系相对较简单.Nested Loop Join 的基本原理是每次从左表获取一行, 然后用这行数据和右表进行 Join. 与右表进行 Join 时, 可以通过索引查询降低复杂度. 表结构123456789101112131415local queryquery = string.format([[ CREATE TABLE t%d( c1 int primary key, c2 int, c3 int, v1 CHAR(60), v2 CHAR(60), v3 CHAR(60), v4 CHAR(60), v5 CHAR(60), v6 CHAR(60), v7 CHAR(60), v8 CHAR(60), v9 CHAR(60) )]], table_id)do_query(drv, con, &quot;create index t2_i1 on t2(c2) local&quot;)do_query(drv, con, &quot;create index t2_i2 on t2(c3) local&quot;)ival = sysbench.rand.default(1, sysbench.opt.table_size)left_min = ival - 100;left_max = ival + 100;cond = string.format(&quot;A.c1 &gt;= %d and A.c1 &lt; %d and A.c2 = B.c2 and A.c3 = B.c3&quot;, left_min, left_max)query = &quot;select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where &quot; .. cond 查询语句123456789101112131415161. 原始查询语句 select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and A.c2 = B.c2 and A.c3 = B.c3; select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and A.c2 = B.c2 and A.c3 = B.c3; explain select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and A.c2 = B.c2 and A.c3 = B.c3;2. 当 A.c1 = A.c2 时, 改写后的查询语句 select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and B.c2 &gt;= 100 and B.c2 &lt; 200 and A.c3 = B.c3; select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and B.c2 &gt;= 100 and B.c2 &lt; 200 and A.c3 = B.c3; explain select /*+ordered use_nl(A,B)*/ * from t1 A, t2 B where A.c1 &gt;= 100 and A.c1 &lt; 200 and B.c2 &gt;= 100 and B.c2 &lt; 200 and A.c3 = B.c3;","categories":[{"name":"paper","slug":"paper","permalink":"http://example.com/categories/paper/"}],"tags":[]},{"title":"GFS 论文研读","slug":"GFS-论文研读","date":"2021-11-13T05:27:52.000Z","updated":"2022-01-17T15:59:25.181Z","comments":true,"path":"2021/11/13/GFS-论文研读/","link":"","permalink":"http://example.com/2021/11/13/GFS-%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/","excerpt":"","text":"","categories":[{"name":"paper","slug":"paper","permalink":"http://example.com/categories/paper/"}],"tags":[]}],"categories":[{"name":"database project","slug":"database-project","permalink":"http://example.com/categories/database-project/"},{"name":"paper","slug":"paper","permalink":"http://example.com/categories/paper/"},{"name":"database course","slug":"database-course","permalink":"http://example.com/categories/database-course/"}],"tags":[{"name":"tinykv","slug":"tinykv","permalink":"http://example.com/tags/tinykv/"},{"name":"Raft","slug":"Raft","permalink":"http://example.com/tags/Raft/"},{"name":"cmu 15-445","slug":"cmu-15-445","permalink":"http://example.com/tags/cmu-15-445/"}]}